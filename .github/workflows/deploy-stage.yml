name: Deploy CallData Foundation Platform (Stage)

on:
  push:
    branches:
      - main
    paths:
      - 'terraform/environments/stage/**'
      - 'terraform/modules/foundation-aio/**'
      - 'wazo-ansible/**'
      - '.github/workflows/deploy-stage.yml'
  workflow_dispatch:  # Allow manual trigger

env:
  AWS_REGION: us-east-2
  TF_VERSION: 1.5.0
  ANSIBLE_VERSION: 8.7.0

jobs:
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    outputs:
      tfplan_exitcode: ${{ steps.plan.outputs.exitcode }}

    defaults:
      run:
        working-directory: terraform/environments/stage

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform Format Check
        id: fmt
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init
        id: init
        run: terraform init

      - name: Clean up orphaned resources (if any)
        run: |
          echo "Checking for orphaned IAM resources..."

          # Step 1: Clean up instance profiles FIRST (before roles)
          for PROFILE_NAME in "calldata-foundation-stage-foundation-profile"; do
            echo "Checking for instance profile: $PROFILE_NAME"
            for ROLE_NAME in "calldata-foundation-stage-foundation-ssm-role"; do
              aws iam remove-role-from-instance-profile --instance-profile-name $PROFILE_NAME --role-name $ROLE_NAME 2>/dev/null || true
            done
            aws iam delete-instance-profile --instance-profile-name $PROFILE_NAME 2>/dev/null || true
          done

          # Step 2: Clean up IAM roles (after instance profiles are removed)
          for ROLE_NAME in "calldata-foundation-stage-foundation-ssm-role"; do
            echo "Checking for role: $ROLE_NAME"
            aws iam list-role-policies --role-name $ROLE_NAME 2>/dev/null | \
              jq -r '.PolicyNames[]' | \
              xargs -I {} aws iam delete-role-policy --role-name $ROLE_NAME --policy-name {} 2>/dev/null || true
            aws iam list-attached-role-policies --role-name $ROLE_NAME 2>/dev/null | \
              jq -r '.AttachedPolicies[].PolicyArn' | \
              xargs -I {} aws iam detach-role-policy --role-name $ROLE_NAME --policy-arn {} 2>/dev/null || true
            aws iam delete-role --role-name $ROLE_NAME 2>/dev/null || true
          done

          # Step 3: Clean up EC2 instances with EIPs
          echo "Checking for orphaned EC2 instances..."
          for INSTANCE_NAME in "calldata-foundation-stage-foundation"; do
            INSTANCE_ID=$(aws ec2 describe-instances \
              --region ${{ env.AWS_REGION }} \
              --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running,stopped,stopping" \
              --query 'Reservations[0].Instances[0].InstanceId' \
              --output text 2>/dev/null || echo "")

            if [ ! -z "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "None" ]; then
              echo "Found orphaned instance: $INSTANCE_ID ($INSTANCE_NAME)"
              aws ec2 describe-addresses --region ${{ env.AWS_REGION }} \
                --filters "Name=instance-id,Values=$INSTANCE_ID" \
                --query 'Addresses[*].[AssociationId,AllocationId]' \
                --output text | while read ASSOC_ID ALLOC_ID; do
                if [ ! -z "$ASSOC_ID" ]; then
                  aws ec2 disassociate-address --association-id $ASSOC_ID --region ${{ env.AWS_REGION }} 2>/dev/null || true
                fi
                if [ ! -z "$ALLOC_ID" ]; then
                  aws ec2 release-address --allocation-id $ALLOC_ID --region ${{ env.AWS_REGION }} 2>/dev/null || true
                fi
              done
              aws ec2 terminate-instances --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }} 2>/dev/null || true
              for j in {1..12}; do
                STATE=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }} \
                  --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "terminated")
                if [ "$STATE" = "terminated" ]; then break; fi
                sleep 5
              done
            fi
          done

          # Step 4: Clean up S3 buckets
          for BUCKET_NAME in "calldata-foundation-stage-ssm-logs"; do
            if aws s3api head-bucket --bucket $BUCKET_NAME --region ${{ env.AWS_REGION }} 2>/dev/null; then
              echo "Found bucket: $BUCKET_NAME, cleaning up..."
              aws s3api put-bucket-versioning --bucket $BUCKET_NAME --versioning-configuration Status=Suspended --region ${{ env.AWS_REGION }} 2>/dev/null || true
              aws s3 rm s3://$BUCKET_NAME --recursive --region ${{ env.AWS_REGION }} 2>/dev/null || true
              aws s3api delete-bucket --bucket $BUCKET_NAME --region ${{ env.AWS_REGION }} 2>/dev/null || true
            fi
          done
          echo "Cleanup completed"
        continue-on-error: true

      - name: Import existing S3 bucket if present
        run: |
          BUCKET_NAME="calldata-foundation-stage-ssm-logs"
          if aws s3api head-bucket --bucket $BUCKET_NAME --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "Bucket $BUCKET_NAME exists, attempting to import..."
            terraform import module.foundation.aws_s3_bucket.ssm_logs $BUCKET_NAME 2>&1 || true
            terraform import module.foundation.aws_s3_bucket_versioning.ssm_logs $BUCKET_NAME 2>&1 || true
            terraform import module.foundation.aws_s3_bucket_public_access_block.ssm_logs $BUCKET_NAME 2>&1 || true
          fi
        continue-on-error: true

      - name: Terraform Validate
        id: validate
        run: terraform validate -no-color

      - name: Terraform Plan
        id: plan
        run: |
          set +e
          terraform plan -no-color -out=tfplan -detailed-exitcode
          PLAN_EXIT=$?
          echo "exitcode=${PLAN_EXIT}" >> $GITHUB_OUTPUT
          if [ $PLAN_EXIT -eq 0 ] || [ $PLAN_EXIT -eq 2 ]; then
            terraform show -no-color tfplan > plan.txt
            exit 0
          else
            exit 1
          fi

      - name: Upload Plan
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/environments/stage/tfplan
          retention-days: 5

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && (needs.terraform-plan.outputs.tfplan_exitcode == '0' || needs.terraform-plan.outputs.tfplan_exitcode == '2')

    defaults:
      run:
        working-directory: terraform/environments/stage

    outputs:
      foundation_ip: ${{ steps.output.outputs.foundation_ip }}
      instance_id: ${{ steps.output.outputs.instance_id }}
      ssm_bucket: ${{ steps.output.outputs.ssm_bucket }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init

      - name: Import existing S3 bucket if present
        run: |
          BUCKET_NAME="calldata-foundation-stage-ssm-logs"
          if aws s3api head-bucket --bucket $BUCKET_NAME --region ${{ env.AWS_REGION }} 2>/dev/null; then
            terraform import module.foundation.aws_s3_bucket.ssm_logs $BUCKET_NAME 2>&1 || true
            terraform import module.foundation.aws_s3_bucket_versioning.ssm_logs $BUCKET_NAME 2>&1 || true
            terraform import module.foundation.aws_s3_bucket_public_access_block.ssm_logs $BUCKET_NAME 2>&1 || true
          fi
        continue-on-error: true

      - name: Terraform Apply
        run: terraform apply -auto-approve

      - name: Get Outputs
        id: output
        run: |
          echo "foundation_ip=$(terraform output -raw foundation_public_ip)" >> $GITHUB_OUTPUT
          echo "instance_id=$(terraform output -raw foundation_instance_id)" >> $GITHUB_OUTPUT
          echo "ssm_bucket=$(terraform output -raw ssm_logs_bucket)" >> $GITHUB_OUTPUT

      - name: Wait for Instance Ready
        run: |
          INSTANCE_ID=$(terraform output -raw foundation_instance_id)
          echo "Waiting for instance $INSTANCE_ID to be ready..."
          aws ec2 wait instance-status-ok --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }}
          echo "Waiting for cloud-init to complete (90 seconds)..."
          sleep 90

  ansible-deploy:
    name: Deploy Foundation Platform with Ansible
    runs-on: ubuntu-latest
    needs: terraform-apply

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Ansible
        run: |
          pip install ansible==${{ env.ANSIBLE_VERSION }}
          pip install boto3 botocore
          ansible-galaxy collection install community.general amazon.aws
          ansible-galaxy collection install community.aws:>=7.0.0
          curl "https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb" -o "session-manager-plugin.deb"
          sudo dpkg -i session-manager-plugin.deb

      - name: Create Ansible Configuration
        run: |
          cat > wazo-ansible/ansible.cfg << EOF
          [defaults]
          host_key_checking = False
          timeout = 60
          remote_tmp = /tmp/.ansible-\${USER}/tmp

          [ssh_connection]
          ssh_args = -o ControlMaster=auto -o ControlPersist=60s -o ServerAliveInterval=30
          EOF

      - name: Install Ansible PostgreSQL Requirements
        run: ansible-galaxy install -r wazo-ansible/requirements-postgresql.yml

      - name: Create Ansible Inventory
        run: |
          INSTANCE_ID="${{ needs.terraform-apply.outputs.instance_id }}"
          SSM_BUCKET="${{ needs.terraform-apply.outputs.ssm_bucket }}"
          mkdir -p wazo-ansible/inventories

          cat > wazo-ansible/inventories/uc-engine << EOF
          [database]
          foundation-stage ansible_host=${INSTANCE_ID} ansible_connection=community.aws.aws_ssm ansible_aws_ssm_region=us-east-2 ansible_aws_ssm_bucket_name=${SSM_BUCKET} ansible_python_interpreter=/usr/bin/python3 ansible_user=admin ansible_aws_ssm_timeout=60 ansible_aws_ssm_retries=5

          [b2bua]
          foundation-stage ansible_host=${INSTANCE_ID} ansible_connection=community.aws.aws_ssm ansible_aws_ssm_region=us-east-2 ansible_aws_ssm_bucket_name=${SSM_BUCKET} ansible_python_interpreter=/usr/bin/python3 ansible_user=admin ansible_aws_ssm_timeout=60 ansible_aws_ssm_retries=5

          [engine_api]
          foundation-stage ansible_host=${INSTANCE_ID} ansible_connection=community.aws.aws_ssm ansible_aws_ssm_region=us-east-2 ansible_aws_ssm_bucket_name=${SSM_BUCKET} ansible_python_interpreter=/usr/bin/python3 ansible_user=admin ansible_aws_ssm_timeout=60 ansible_aws_ssm_retries=5

          [uc_ui]
          foundation-stage ansible_host=${INSTANCE_ID} ansible_connection=community.aws.aws_ssm ansible_aws_ssm_region=us-east-2 ansible_aws_ssm_bucket_name=${SSM_BUCKET} ansible_python_interpreter=/usr/bin/python3 ansible_user=admin ansible_aws_ssm_timeout=60 ansible_aws_ssm_retries=5

          [all:vars]
          ansible_shell_type=sh
          ansible_shell_executable=/bin/sh
          EOF

      - name: Wait for SSM Agent
        run: |
          INSTANCE_ID="${{ needs.terraform-apply.outputs.instance_id }}"
          for i in {1..45}; do
            STATUS=$(aws ssm describe-instance-information \
              --filters "Key=InstanceIds,Values=${INSTANCE_ID}" \
              --query "InstanceInformationList[0].PingStatus" \
              --output text --region ${{ env.AWS_REGION }} || echo "NotFound")
            if [ "$STATUS" = "Online" ]; then
              echo "SSM agent is online!"
              sleep 30
              break
            fi
            echo "SSM agent status: ${STATUS}. Waiting... (attempt $i/45)"
            sleep 20
          done

      - name: Wait for package manager
        run: |
          INSTANCE_ID="${{ needs.terraform-apply.outputs.instance_id }}"
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["for i in {1..60}; do if ! sudo fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; then exit 0; fi; sleep 10; done; exit 1"]' \
            --region ${{ env.AWS_REGION }} \
            --output text --query 'Command.CommandId')
          for i in {1..70}; do
            STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${INSTANCE_ID}" \
              --region ${{ env.AWS_REGION }} --query 'Status' --output text 2>/dev/null || echo "Pending")
            if [ "$STATUS" = "Success" ]; then break; fi
            sleep 10
          done

      - name: Run Wazo Platform Ansible Playbook
        run: |
          cd wazo-ansible
          export AWS_REGION=${{ env.AWS_REGION }}
          MAX_ATTEMPTS=5
          ATTEMPT=1
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Running Ansible playbook (attempt $ATTEMPT/$MAX_ATTEMPTS)..."
            if ansible-playbook -i inventories/uc-engine uc-engine.yml --become --become-user=root \
              -e "engine_api_configure_wizard=true" \
              -e "engine_api_root_password=${{ secrets.WAZO_ROOT_PASSWORD }}" \
              -e "api_client_name=api-client" \
              -e "api_client_password=${{ secrets.WAZO_API_PASSWORD }}" \
              -e "tenant_name=calldata" -vvv; then
              echo "Ansible playbook completed successfully!"
              exit 0
            else
              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                WAIT_TIME=$((60 + (ATTEMPT * 30)))
                echo "Waiting $WAIT_TIME seconds before retry..."
                sleep $WAIT_TIME
              fi
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done
          exit 1

      - name: Install Wazo UI and Create Admin User
        run: |
          INSTANCE_ID="${{ needs.terraform-apply.outputs.instance_id }}"

          # Install wazo-ui package
          echo "Installing wazo-ui..."
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["apt-get update && apt-get install -y wazo-ui && systemctl restart nginx"]' \
            --region ${{ env.AWS_REGION }} \
            --output text --query 'Command.CommandId')

          for i in {1..30}; do
            STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${INSTANCE_ID}" \
              --region ${{ env.AWS_REGION }} --query 'Status' --output text 2>/dev/null || echo "Pending")
            if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ]; then break; fi
            sleep 10
          done

          # Create admin user
          echo "Creating admin user..."
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"wazo-auth-cli user list | grep -q '^| .* root ' || wazo-auth-cli user create root --password '${{ secrets.WAZO_ROOT_PASSWORD }}' --purpose external_api --enable\"]" \
            --region ${{ env.AWS_REGION }} \
            --output text --query 'Command.CommandId')

          for i in {1..20}; do
            STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${INSTANCE_ID}" \
              --region ${{ env.AWS_REGION }} --query 'Status' --output text 2>/dev/null || echo "Pending")
            if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ]; then break; fi
            sleep 5
          done

          # Get root user UUID and assign admin policy
          echo "Assigning admin policy..."
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["ROOT_UUID=$(wazo-auth-cli user list | grep \" root \" | awk \"{print \\$2}\"); if [ ! -z \"$ROOT_UUID\" ]; then wazo-auth-cli user add --policy wazo_default_admin_policy $ROOT_UUID 2>/dev/null || echo Policy already assigned; fi"]' \
            --region ${{ env.AWS_REGION }} \
            --output text --query 'Command.CommandId')

          for i in {1..20}; do
            STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${INSTANCE_ID}" \
              --region ${{ env.AWS_REGION }} --query 'Status' --output text 2>/dev/null || echo "Pending")
            if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ]; then break; fi
            sleep 5
          done

          echo "Admin user setup complete"

      - name: Install Let's Encrypt SSL Certificate
        run: |
          INSTANCE_ID="${{ needs.terraform-apply.outputs.instance_id }}"

          echo "Installing Let's Encrypt certificate..."
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["apt-get install -y certbot python3-certbot-nginx && certbot --nginx -d stage.foundation.calldata.app --non-interactive --agree-tos --email admin@calldata.app --redirect 2>&1 || echo Certificate may already exist"]' \
            --region ${{ env.AWS_REGION }} \
            --timeout-seconds 300 \
            --output text --query 'Command.CommandId')

          for i in {1..45}; do
            STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${INSTANCE_ID}" \
              --region ${{ env.AWS_REGION }} --query 'Status' --output text 2>/dev/null || echo "Pending")
            if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ]; then break; fi
            sleep 10
          done

          echo "SSL certificate setup complete"

      - name: Health Check
        run: |
          FOUNDATION_IP="${{ needs.terraform-apply.outputs.foundation_ip }}"
          sleep 30
          for i in {1..10}; do
            if curl -k -f "https://${FOUNDATION_IP}"; then
              echo "Foundation Platform is accessible!"
              break
            fi
            sleep 30
          done

  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [terraform-apply, ansible-deploy]
    if: always()

    steps:
      - name: Deployment Status
        run: |
          echo "=================================================="
          echo "CallData Foundation Platform (Stage) Summary"
          echo "=================================================="
          echo ""
          echo "Infrastructure: ${{ needs.terraform-apply.result }}"
          echo "Configuration: ${{ needs.ansible-deploy.result }}"
          echo ""
          echo "Web Interface: https://stage.foundation.calldata.app"
          echo "Direct IP: https://${{ needs.terraform-apply.outputs.foundation_ip }}"
          echo "Instance ID: ${{ needs.terraform-apply.outputs.instance_id }}"
          echo ""
          echo "SIP: stage.foundation.calldata.app:5060"
          echo "=================================================="
